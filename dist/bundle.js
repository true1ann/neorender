/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// TODO: refine error & warning messages\nclass NeoRender {\n    static defineComponent(config) {\n        try {\n            if (!config.name || !config.template) {\n                throw new Error('Components must have a Name and a Template.');\n                return false;\n            }\n            this.components[config.name] = config;\n            return true;\n        }\n        catch (err) {\n            throw new Error(err);\n            return false;\n        }\n    }\n    static untilVisible(selector) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const element = document.querySelector(selector);\n            if (!element) {\n                throw new Error(`Element not found for selector: ${selector}`);\n            }\n            function isVisible(sel) {\n                const el = document.querySelector(sel);\n                if (!el)\n                    return false;\n                const style = window.getComputedStyle(el);\n                return style.display !== 'none' &&\n                    style.visibility !== 'hidden' &&\n                    style.opacity !== '0';\n            }\n            return new Promise((resolve) => {\n                const observer = new IntersectionObserver((entries) => {\n                    entries.forEach(entry => {\n                        if (entry.isIntersecting) {\n                            observer.unobserve(entry.target);\n                            const checkVisibility = () => __awaiter(this, void 0, void 0, function* () {\n                                while (!isVisible(selector)) {\n                                    yield new Promise(resolve => setTimeout(resolve, 100));\n                                }\n                                resolve(true);\n                            });\n                            checkVisibility();\n                        }\n                    });\n                }, {\n                    root: null,\n                    rootMargin: '0px',\n                    threshold: 0.1\n                });\n                observer.observe(element);\n            });\n        });\n    }\n    static generateComponentId() {\n        const generateId = () => {\n            return [...Array(64)].map(() => \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[Math.floor(Math.random() * 62)]).join(\"\");\n        };\n        let id;\n        do {\n            id = generateId();\n        } while (this.componentSelectors.includes(id));\n        id = `NRCID_${id}`;\n        this.componentSelectors.push(id);\n        return id;\n    }\n    static findComponentById(id) {\n        return document.querySelector(`[data-nr-cid=${id}]`);\n    }\n    static returnComponent(componentName, config, env) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const component = this.components[componentName];\n                if (!component) {\n                    throw new Error(`Component ${componentName} is not defined.`);\n                    return false;\n                }\n                let componentConfig;\n                componentConfig = {\n                    \"useShadowRoot\": true,\n                    \"closeShadowRoot\": false,\n                    \"mountConfig\": {\n                        \"id\": null,\n                        \"className\": null\n                    },\n                    \"lazyLoad\": false\n                };\n                if (typeof component.beforeCreate === 'function') {\n                    const returnedConfig = component.beforeCreate(config, env);\n                    componentConfig = Object.assign(Object.assign({}, componentConfig), returnedConfig);\n                }\n                if (componentConfig.lazyLoad) {\n                    if (env.mountingTo) {\n                        yield this.untilVisible(env.mountingTo);\n                    }\n                    else {\n                        console.warn(`Component ${componentName} was probably mounted with nr.scriptMount(). Full lazyLoading IS NOT supported by nr.scriptMount()\\nIf not, please leave an issue on GitHub`);\n                    }\n                }\n                const container = document.createElement('div');\n                let componentRoot;\n                if (componentConfig.useShadowRoot) {\n                    componentRoot = container.attachShadow({ mode: componentConfig.closeShadowRoot ? 'closed' : 'open' });\n                }\n                else {\n                    componentRoot = container;\n                }\n                if (typeof componentConfig.mountConfig.id == 'string')\n                    container.id = componentConfig.mountConfig.id;\n                if (typeof componentConfig.mountConfig.className == 'string')\n                    container.className = componentConfig.mountConfig.className;\n                componentRoot.innerHTML = component.template;\n                if (component.scopedStyles) {\n                    if (componentConfig.useShadowRoot) {\n                        const styleElement = document.createElement('style');\n                        styleElement.textContent = component.scopedStyles;\n                        componentRoot.appendChild(styleElement);\n                    }\n                    else {\n                        console.warn(`Component \"${component.name}\" has scopedStyles, but shadowRoot is disabled. scopedStyles will be ignored.`);\n                    }\n                }\n                if (typeof component.main === 'function') {\n                    component.main(componentRoot, config, env);\n                }\n                const cid = this.generateComponentId();\n                container.setAttribute('data-nr-cid', cid);\n                return { context: componentRoot, config: componentConfig, root: container, nr: { cid: cid } };\n            }\n            catch (err) {\n                throw new Error(err);\n                return false;\n            }\n        });\n    }\n    static mount(componentName, selector, config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            try {\n                const component = this.components[componentName];\n                if (!component) {\n                    throw new Error(`Component ${componentName} is not defined.`);\n                    return false;\n                }\n                const element = document.querySelector(selector);\n                if (!element) {\n                    throw new Error(`Element ${element} is not found.`);\n                    return false;\n                }\n                if (this.mountedComponents[selector]) {\n                    if (this.mountedComponents[selector] === componentName) {\n                        console.warn(`Component ${this.mountedComponents[selector]} is already mounted to ${selector}`);\n                        return true;\n                    }\n                    throw new Error(`Element ${selector} already has a component mounted to it: ${this.mountedComponents[selector]}`);\n                    return false;\n                }\n                const componentObj = yield this.returnComponent(componentName, config, { \"type\": \"mount\", \"mountingTo\": selector });\n                if (componentObj) {\n                    element.appendChild(componentObj.root);\n                    this.mountedComponents[selector] = componentName;\n                }\n                else {\n                    throw new Error(`Failed to mount ${componentName}: nr.returnComponent() didnt return anything`);\n                }\n                if (typeof component.afterCreate === 'function') {\n                    component.afterCreate((_a = this.findComponentById(componentObj.nr.cid)) === null || _a === void 0 ? void 0 : _a.shadowRoot, config, { \"type\": \"mount\", \"mountingTo\": selector });\n                }\n                if (typeof component.lazyLoad == 'function' && componentObj) {\n                    yield this.untilVisible(`[data-nr-cid=${componentObj.nr.cid}]`);\n                    component.lazyLoad((_b = this.findComponentById(componentObj.nr.cid)) === null || _b === void 0 ? void 0 : _b.shadowRoot, config, { \"type\": \"mount\", \"mountingTo\": selector });\n                }\n                return true;\n            }\n            catch (err) {\n                throw new Error(err);\n                return false;\n            }\n        });\n    }\n    static remount(selector, componentName) {\n        try {\n            this.unmount(selector);\n            if (componentName)\n                delete this.mountedComponents[selector];\n            return this.mount(componentName || this.mountedComponents[selector], selector, null);\n        }\n        catch (err) {\n            throw new Error(err);\n            return false;\n        }\n    }\n    static unmount(selector) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            try {\n                const componentName = this.mountedComponents[selector];\n                if (componentName) {\n                    const component = this.components[componentName];\n                    if (typeof component.beforeDelete === 'function') {\n                        yield component.beforeDelete((_a = document.querySelector(`${selector} > div`)) === null || _a === void 0 ? void 0 : _a.shadowRoot);\n                    }\n                    const element = document.querySelector(selector);\n                    if (element) {\n                        element.innerHTML = '';\n                    }\n                    delete this.mountedComponents[selector];\n                    return true;\n                }\n                else {\n                    console.warn(`Tried to unmount NR from ${selector}, but nothing was mounted to it.`);\n                    return true;\n                }\n            }\n            catch (err) {\n                throw new Error(err);\n                return false;\n            }\n        });\n    }\n    static scriptMount(componentName, config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            try {\n                const scriptTag = document.currentScript;\n                if (!scriptTag) {\n                    throw new Error(`scriptMount is NOT meant to be executed in script, or console. use mount or returnComponent instead.`);\n                    return false;\n                }\n                const component = this.components[componentName];\n                if (!component) {\n                    throw new Error(`Component ${componentName} is not defined.`);\n                    return false;\n                }\n                const componentObj = yield this.returnComponent(componentName, config, { \"type\": \"scriptMount\", \"mountingTo\": null });\n                if (scriptTag.parentNode && componentObj) {\n                    scriptTag.parentNode.replaceChild(componentObj.root, scriptTag);\n                }\n                else {\n                    throw new Error('Parent node of the script tag is null or componentObj is false.');\n                    return false;\n                }\n                if (typeof component.afterCreate === 'function') {\n                    component.afterCreate((_a = this.findComponentById(componentObj.nr.cid)) === null || _a === void 0 ? void 0 : _a.shadowRoot, config, { \"type\": \"scriptMount\", \"mountingTo\": undefined });\n                }\n                if (typeof component.lazyLoad === 'function') {\n                    yield this.untilVisible(`[data-nr-cid=${componentObj.nr.cid}]`);\n                    component.lazyLoad((_b = this.findComponentById(componentObj.nr.cid)) === null || _b === void 0 ? void 0 : _b.shadowRoot, config, { \"type\": \"scriptMount\", \"mountingTo\": undefined });\n                }\n            }\n            catch (err) {\n                throw new Error(err);\n            }\n        });\n    }\n}\nNeoRender.components = {};\nNeoRender.mountedComponents = {};\n// TODO: ^^^^^^^^^^^^^^^^^ \n// change this to NOT use an array and instead use [data-nr-mounted=true] and [data-nr-mounted-component-name=componentName]\n// to allow query selectors based on the mounted component with built-in document.querySelector(All)\nNeoRender.componentSelectors = [];\nNeoRender.version = 'NeoRender Sr4';\nNeoRender.verNum = 4;\nwindow.nr = NeoRender;\n\n\n//# sourceURL=webpack://neorender/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"](0, __webpack_exports__);
/******/ 	
/******/ })()
;